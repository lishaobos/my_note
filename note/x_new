***关于js内存机制
    参考网站：https://blog.csdn.net/LY_code/article/details/79809007
    1.数组，对象，函数
        数组和对象是引用数据类型，他们三个都存在于堆空间中，对象中的字段也指向堆空间的数据
    2.其他基本数据类型
        存在于栈空间中
    栈和堆的区别
　　一、堆栈空间分配区别： 
　　1、栈（操作系统）：由操作系统自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈； 
　　2、堆（操作系统）： 一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收，分配方式倒是类似于链表。 
　　二、堆栈缓存方式区别： 
　　1、栈使用的是一级缓存， 他们通常都是被调用时处于存储空间中，调用完毕立即释放； 
　　2、堆是存放在二级缓存中，生命周期由虚拟机的垃圾回收算法来决定（并不是一旦成为孤儿对象就能被回收）。所以调用这些对象的速度要相对来得低一些。 
　　三、堆栈数据结构区别： 
　　堆（数据结构）：堆可以被看成是一棵树，如：堆排序； 
　　栈（数据结构）：一种先进后出的数据结构。


***关于 js 的垃圾回收机制
    js垃圾回收器会定期回收内存中不继续使用的变量，释放内存
    参考网站：
        https://www.cnblogs.com/zhwl/p/4664604.html
        http://www.cnblogs.com/TomXu/archive/2012/01/18/2312463.html
    1.标记清除法
        在函数声明一个变量的时候，就将这个变量标记为“进入环境”。从逻辑上讲，永远都不能释放进入环境的变量作占用的内存，
        因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其标记为“离开环境”。垃圾回收器在运行
        时候会给存储在内存中中的所有变量都加上标记。然后它会去掉环境中的变量以及被环境中的变量引用的变量的标记（闭包）。
        在此之后再被标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后，垃圾回收器完成内存清楚工作，
        销毁那些带标记的值并回收他们所占用的内存空间。
        在JavaScript 中，全局变量（Global）和window 对象会一直存在，不会被垃圾收集器回收； 
        递归所用到的所有（包括变量和方法），都不会被回收； 
        所有没有被标记为“活跃（active）”的，都会被认为是垃圾，收集器释放会回收垃圾，并把内存还给操作系统。
        例：
        function test(){ 
            var a = 10 ; //被标记 ，进入环境 
            var b = 20 ; //被标记 ，进入环境 
        } 
        test(); //执行完毕 之后 a、b又被标离开环境，被回收
    2.引用计数法
        引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是1。
        如果同一个值又被赋给另一个变量，则该值的引用次数加1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减1。
        当这个值的引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。这样，当垃圾回收器下次再运行时，
        它就会释放那些引用次数为0的值所占用的内存。但是很重要的一点是当遇到循环引用的时候，函数的引用次数就不会为0，所以不会被垃圾回收器回收内存，
        会造成内存泄露。在IE中涉及COM对象，就会存在循环引用的问题。
        例：
        function test(){ 
            var a = {} ; //a的引用次数为0 
            var b = a ; //a的引用次数加1，为1 
            var c =a; //a的引用次数再加1，为2 
            var b ={}; //a的引用次数减1，为1 
        }


***关于闭包和垃圾回收机制
    参考网站：  
        https://blog.csdn.net/johnny0991/article/details/51778436
        https://blog.csdn.net/Haley_Guo/article/details/80362559
    1.闭包基本概念
        闭包一般实在函数体内部定义一个函数，内部函数可以访问外部函数的参数，一般以函数作为返回值，或者函数传递参数出现
        1.函数作为返回值
            会导致函数体里面声明的a变量无法被回收
            var a = 1
            function big(){
                var a = 2
                return function (){
                    console.log(a)
                }
            }
            big()() //打印出来 2
        2.函数传递参数
            这个让人明白函数体访问到的参数是在他的作用域的参数，也就是声明函数的地方。
            var a = 1;
            function small (){
                console.log(a)
            }
            function big (callback){
                var a = 2
                callback()
            }
            big(small) //打印出来 1
    2.闭包为什么会导致内存泄漏
        能导致内存泄漏的一定是引用类型的变量，比如函数和其他自定义对象。而值类型的变量是不存在内存泄漏的，比如字符串、数字、布尔值等。
        因为值类型是靠复制来传递的，而引用类型是靠类似c语言中的指针来传递的。可以认为一个引用类型的变量就是一个指向某个具体的内存地址的指针。

        内存泄漏是指我们已经无法再通过js代码来引用到某个对象，但垃圾回收器却认为这个对象还在被引用，因此在回收的时候不会释放它。
        导致了分配的这块内存永远也无法被释放出来。如果这样的情况越来越多，会导致内存不够用而系统崩溃。

        什么情况会引起内存泄漏？
        虽然有垃圾回收机制但是我们编写代码操作不当还是会造成内存泄漏。

        意外的全局变量引起的内存泄漏。 
        原因：全局变量，不会被回收。 
        解决：使用严格模式避免。

        闭包引起的内存泄漏 
        原因：闭包可以维持函数内局部变量，使其得不到释放。 
        解决：将事件处理函数定义在外部，解除闭包,或者在定义事件处理函数的外部函数中，删除对dom的引用。

        没有清理的DOM元素引用 
        原因：虽然别的地方删除了，但是对象中还存在对dom的引用 
        解决：手动删除。

        被遗忘的定时器或者回调 
        原因：定时器中有dom的引用，即使dom删除了，但是定时器还在，所以内存中还是有这个dom。 
        解决：手动删除定时器和dom。

        子元素存在引用引起的内存泄漏 
        原因：div中的ul li 得到这个div，会间接引用某个得到的li，那么此时因为div间接引用li，即使li被清空，也还是在内存中，并且只要li不被删除，他的父元素都不会被删除。 
        解决：手动删除清空。


***原型链
    https://www.jianshu.com/p/116ea3be6ef5
    https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain
    https://www.zhihu.com/question/34183746
    https://www.cnblogs.com/libin-1/p/6014925.html



***关于Object.defineProperty(obj,'yo',{ // obj是定义的对象，yo是属性
    set(e){
        // 当 obj.yo = anythine 就会进来这个函数，e 是我们修改的 obj对象的yo属性的值
    },
    get(){
        // 当 obj.yo  就会进来这个函数
    },
    value:'xxx', // 这个就是我们定义的 yo 属性的值
    enumerable: false // 这个是 false 就是代表不可枚举, true 就是代表可枚举
    configurable: false //如果为false,就不能设置他的value
})
    1.对象的可枚举属性和不可枚举属性的区别
        1.可枚举属性就是我们 for in 循环可以打印出来的属性
        2.不可枚举属性我们在对象中可以使用，也可以看见，但是 for in 循环是打印不出来这个属性的

***关于es6连续箭头函数
    let yo = a => b => return a + b
    相当于 function yo(a){
            return function (b){
                return a + b
            }
          }
    执行形式：yo(2)(3) //都是这样
    
    
    
***关于 js 执行上下文，环境栈
