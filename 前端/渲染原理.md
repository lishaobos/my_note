1. script 标签会阻塞后面的解析（包含类似 img 的 src 请求），但不会阻塞后面脚本的请求

2. hitTest是 webkit 中的一种检查触发事件在哪个区域的算法，检查哪个元素是直接的事件目标

3. dom 事件分为很多种，用户相关的是 UIEvent，其他的还有 CustomEvent MutationEvent，UIEvent 又可以分为很多种，包括但是不限于 FocusEvent MouseEvent KeyBoardEvent CompositionEvent 等

4. webkit 的浏览器事件处理，首先是做 HitTest，查找事件发生处的元素，检测该元素有没有监听者，如果网页的相关节点注册了事件的监听，那么浏览器会把事件派发给 webkit 来处理，因为浏览器需要理解和处理这个事件，比如说鼠标滚轮滚动，但是鼠标的位置在一个 html 元素之上，该元素需要接收滚动事件

5. webkit 会为页面中的可视化节点创建对应的 RenderObject 对象，就会形成 RenderObject 树，head meta 等不是可视节点，不会被创建 RenderObject 对象

6. 网页是可以分层的，这有两点原因，一是为了网页开发者开发网页并设置网页的层次，二是为了简化渲染的逻辑，webkit 会为网页的层次创建相对应的 RenderLayer 对象，当某些类型的 RenderObject 节点或者具有某些 CSS 样式的 RenderObject 节点出现的时候，webkit 就会为这些节点创建 RenderLayer 对象，一般来说，某个 RenderObject 节点的后代都属于该节点，除非 webkit 根据规则为某个后代 RenderObject 节点创建了一个新的 RenderLayer 对象

6.1 RenderLayer 树是基于 RenderObject 树创建的一颗新树，RenderLayer 节点和 RenderObject 节点不是一一对应关系，而是一对多的关系，以下的特点都会为 RenderObject 创建新的 RenderLayer 节点

  DOM 树的 Document 节点对应的 RenderView 节点
  DOM 树中的 Document 的子女节点，也就是 HTML 节点对应的 RenderBlock 节点
  显示的指定 CSS 位置的 RenderObject 节点
  透明效果的 RenderObject 节点
  节点有 overflow，alpha 或者反射等效果的 RenderObject 节点
  使用 Canvas 2d，3d 技术的 RenderObject 节点
  video 节点对应的 RenderObject 节点

7. 每个 RenderLayer 节点包含的 RenderObject 节点其实是一颗 RenderObject 子树

8. 在完成 dom 树的构建之后，webkit 渲染到网页，渲染方式有两种：一种是软件渲染，一种是硬件加速渲染，每个 RenderLayer 对象可以被想象成为图像中的一个层，每个层一同构建了一个图像，在渲染的过程中，如果由 cpu 来完成，那么称之为软件绘图，如果由 GPU 来完成，称之为 gpu 硬件加速绘图，理想情况下，每个层都有个绘制的存储区域，这个存储区域保存绘图的结果，最后，需要将这些层的内容合并到同一个图层之中，称之为 合成（compositing），使用了合成技术的渲染称之为合成化渲染

9. 图层渲染的时候有三种方式，第一种是纯 CPU 绘图，第二种是纯 GPU 绘图，第三种是两者的混合

10. 使用 GPU 绘图不一定比使用 CPU 绘图在性能上有优势，例如绘制文字，点，线等，原因是 CPU 使用缓存机制有效减少了重复绘制的开销且不需要 GPU 并行，其次 GPU 的内存资源相对于 CPU 比较紧张，而且网页的分层是的 GPU 的内存使用相对比较多

10.1. 软件渲染是很常见的技术，也是浏览器最早使用的渲染方式，这一技术比较节省内存，但是软件渲染只能处理 2d 方面的操作，简单的网页没有复杂绘图或者多媒体方面的需求就适合用软件渲染方式，但是 h5 有很多新的特性，比如 css3D webgl， video，canvas2d等，性能和能力都不足

10.2. 对于硬件加速的合成渲染方式来说，每个层的绘制和所有层的合成均使用 GPU 硬件来完成，这对需要使用 3d 绘图的操作来说非常合适，在 RenderLayer 树之后，webkit 和 chromium 还需要建立更多的内部表示，例如 GraphicsLayer 树，合成器中的程（chromium 的 CCLayer）等，目前是支持硬件加速机制，这显然会消耗更多的内存资源，但是硬件加速机制能够支持现在所有的 h5 定义的 2d，3d 绘图标准

10.3. 软件绘图的合成化渲染方式结合了前面两种的有点，因为很多网页可能包含基本的 html 元素，也有一些 h5 的新特性，使用 CPU 绘制一些层，使用 GPU 来绘制某些层，原因当然是前面所述的基于性能和内存方面综合考虑的结果

10.4. 一般的网页用软件渲染，速度更快，相较于硬件加速，他不需要 GPU 内存和其他资源，硬件加速需要很多的 GPU 内存资源，因为他会为每个层分配内存对象，很多时候 GPU 资源就比较紧张

11. 要分析软件渲染过程，需要关注两个方面，RenderLayer 树和他所包含的 RenderObject 子树，对于每个 RenderObject 对象，需要三个阶段绘制自己，第一阶段是绘制该层中所有块的北京和边框，第二阶段是绘制浮动内容，第三阶段是绘制内容部分，轮廓


12. 对于 GPU 绘图，不像软件渲染知识计算其中更新的区域，一旦有更新请求，如果没有分层，引擎可能要绘制所有的区域，因为计算更新部分对 GPU 来说可能耗费更多的时间，当网页分层之后，部分区域的更新可能只在网页的某个层或者几层，不需要将整个网页重新绘制，通过重新绘制一个或多个层，并将他们和之前的曾合成起来，既能使用 GPU 能力，又能减少重绘的开销

13. 理想状况下 RenderLayer 对象和 最终显示出来的图层一一对应，也就是每个 RenderLayer 对象都有一个后端存储与其对应，这样的好处就是每一层更新的时候， webkit 只需更新 RenderLayer 对象包含的节点，重绘该层的内容，但是实际上硬件能力和资源有限，为了节省 GPU 内存，硬件加速机制在 RenderLayer 树建立之后需要做三件事情来完成网页的渲染

13.1. webkit 决定将哪些 RenderLayer 对象组合在一起，形成一个有后端存储的新层，不就会用于之后的合成（compositing），这里称之为合成层（compositing layer），每个新层都有一个或者多个后端存储，这里的后端存储可能是 GPU 内存，对于一个 RenderLayer 对象，如果没有后端存储的新层，那么就是用父亲所使用的合成层

13.2. 将每个合成层包含的这些 RenderLayer 内容绘制在合成层的后端存储中，这里的绘制可以是软件绘制也可以是硬件绘制

13.3. 由合成器（compositor）将多个合成层合成起来，形成网页的最终可视化结果，实际就是一张图片，合成器是一种能够将多个合成层按照这些层的前后顺序，合成层的 3d 变形等设置而合成一个图像结果的设施

14. 如果一个 RenderLayer 对象具有以下特征，那么他就是合成层，每个合成层都有一个 RenderLayerBacking，负责管理 RenderLayer 所需要的所有后端存储，因为后端存储可能需要多个存储空间，webkit 中，存储空间用 GraphicsLayer 类来表示
  1. 具有 CSS 3d 属性或者 CSS 透视效果
  2. 使用了硬件加速的 video
  3. 使用了硬件加速的 canvas 2d 元素或者 webgl 技术
  4. 使用了 CSS 透明效果的动画或者 transform 动画
  5. 使用了硬件加速的 CSS Filters 技术
  6. 使用了 clip 或者 reflection，并且它的后代中包括一个合成层
  7. 有一个 z 坐标比自己小的兄弟节点，且该节点是一个合成层

至于为什么这么做，首先当然是合并一些 RenderLayer 层，这样可以减少内存的使用量，其二是在合并之后，尽量减少合并带来的重回性能和处理上的困难，其三对于那些使用单独层能显著提升性能的 RenderLayer 对象，可以继续使用这些好处，例如 使用 webgl 的 canvas 元素


15. 每个合成层可能有一个或者多个 RenderLayer 对象

16. 所有使用 GPU 硬件加速的操作都是有 GPU 进程来负责完成的

17. chromium 合成器（compositor）的作用就是将多个合成层合并输出一个最终的结果，所以他的输入是多个待合成的合成层，每个层都有一些属性，他的输出就是一个后端存储，例如一个GPU的纹理缓冲区

18.网页加载后，每当绘制新的一帧的时候，一般都需要进行计算布局，绘图，合成三个阶段，前两步耗费的时间比较多，避免这种情况的方法有很多，第一种是用合适的网页分层技术以减少需要从新计算的布局和绘图，第二种是使用 css 3d 变形和动画技术

19. css 3d 变形和动画是 h5 引入的，webkit 对应用该变性技术的 dom 子树使用单独的合成层和硬件加速机制，当时用 javascript 代码改变元素的 3d 变形样式后，chromium 能够减少网页每一帧渲染所需要的时间，webkit 只需要绘制一次元素的内容，之后仅仅设置变换属性值，然后重新合成即可，当合成器调度绘制该合成层的时候，webkit 根本不会发生重新布局和重新绘制，虽然看起来网页内容在变动，但这个只是合成的动作，这些动画都是 webkit 和 chromium 设计的机制和硬件加速带来的效果

20. 网页中还有很多可以使用 GPU 硬件来加速，例如视频解码和播放，2d图形绘制等，webkit 支持他们主要思想依旧是对这些内容进行分层，使用 GPU 强大的绘图能力来支持这些模块






1. 当 webkit 创建 RenderObject 对象之后，每个对象是不知道自己的位置大小等信息的，webkit 根据模型来计算它们的位置，大小信息的过程成为布局计算

2. 布局计算大致分为两类，第一例是对整个 RenderObject 树进行计算，第二类是对 RenderObject 树种某个子树进行计算，常见文本元素或者是 overflow：auto 块的计算，这种情况一般是其子树布局的改变不会影响其周围元素的布局，因而不需要重新计算更大范围的布局

3. 布局计算是一个递归的过程，这是因为一个节点的大小通常需要先计算他的子女节点的位置，大小信息等，主要逻辑都是由 RenderObject 类的 layout 函数来完成：是否需要计算 =》计算宽度 =》 获取 RenderStyle =》 获取垂直方向上的外边距 =》计算子女布局 =》 计算高度，该函数会遍历其中每一个子节点，依次计算他们的布局，每一个元素都有自己的 layout 函数，最后很具子节点大小计算出来自己的高度，整个过程结束，总体来讲，只要样式发生变化，webkit 都需要重新计算，用户翻滚网页也会触发新区域布局的计算，布局计算相对来说是比较耗费时间的，更糟糕的是，布局一旦放生变化， webkit 就需要后面的重新绘制操作

4. RenderObject 用来计算样式布局的函数有 layout() style()等，坐标和绘图相关的操作，webkit 使用这些操作让 RenderObject 对象将内容绘制在转入的绘制结果对象中，例如 paint() repaint() 等

每个 RenderLayer 节点包含的是一个 RenderObject 子树，理想情况下，每个 RenderLayer 都有一个对应的后端类，用来存储该 RenderLayer 对象绘制的结果

5. 软件绘图中是没有合成阶段的，因为渲染结果就是一个位图，绘制每一层的时候都使用该图，区别在于绘制的位置可能不一样，当然每一层都按照从后到前的顺序

6. 混合绘图和GPU绘图都是使用了合成化的渲染技术，也就是使用 GPU 硬件来加速合成这些图层，合成的工作都是由 GPU 来做

7. 混合绘图模式是使用 CPU 来绘图，另外一些层用 GPU 来绘图，对于 CPU 绘图，该层的结果首先是保存在 CPU 内存中，之后被传输到 GPU 内存中，这主要是为了后面的合成工作

8. GPU 绘图是用 GPU 绘制所有合成层




