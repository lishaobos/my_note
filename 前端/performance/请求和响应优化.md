# 请求和响应优化

核心思路：

- 更快的连接传输效率

- 更小的请求资源

- 合适的缓存策略

最佳实践：

- 减少 DNS 查找：每次主机名的解析都需要一次网络往返，从而增加了请求的延迟时间，同时还会阻塞后续的请求。

- 重用 TCP 连接：尽可能的使用持久连接，以消除因 TCP 握手和慢启动导致的延迟。

- 减少 HTTP 重定向：HTTP 冲定向需要额外的 DNS 查询、TCP 握手等非常耗时，最佳的重定向次数为0。

- 压缩传输的资源：比如 Gzip、图片压缩。

- 使用缓存：比如 HTTP 缓存、CDN 缓存、Service Worker 缓存。

- 使用 CDN（内容分发网络）：把数据放在离用户地理位置更近的地方，可以明显减少每次 TCP 连接的网络延迟，增大吞吐量。

- 删除没有必要请求的资源。

- 在客户端缓存资源：缓存必要的应用资源，避免每次都重复请求相同的内容，例如多图片下载可以考虑使用缓存。

- 内容在传输前先压缩：传输数据之前应该先压缩应用资源，把要传输的字节减少到最小，在压缩的时候确保对每种不同的资源采用最好的压缩手段。

- 消除不必要的请求开销：减少请求的 HTTP 首部数据（比如 HTTP COokie）

- 并行处理请求和响应：请求和响应的排队都会导致延迟，可以尝试并行的处理请求和响应（利用多个 HTTP1.1 连接实现并行下载，在可能的情况下使用 HTTP 管道计数）。

- 针对协议版本采取优化措施。升级到 HTTP2.0。

- 根据需要采用服务端渲染方式。这种方式可以解决 SPA 应用首屏渲染慢的问题。

- 采用预渲染的方式快速加载静态页面。页面渲染的极致性能，比较适合静态页面。

## DNS 解析

当网站请求第三方地址的时候需要把域名转化为 IP 地址，然后去请求资源，这个过程就叫做 DNS 解析，如果没有缓存 DNS 结果的话，这个过程大概得 20 - 120ms，如果有很多第三方资源的请求，那么这个时间加起来就很长了

解决办法：

- 1.在 head 处加上第三方的域名的提前解析
    ```
    // 注意点
    // 1.dns-prefetch 仅对跨域的资源有效
    // 2.重复使用会增加重复的 DNS 查询次数
    // 3.DNS 解析请求会耗费流量
    // 4.
    <link rel='dns-prefetch' href='xxx' />
    ```

---


## HTTP 1.1

- 该版本较之前增加了 content: keep-alive，在一个请求产生三次握手这种链接建立的时候，剩下的请求可以复用这个连接，不用每次都去建立连接

- 该版本可以并发请求，chrome 为例可以同时并发请求一个域 6 个请求，他这个响应机制是假设发出了 A，B两个并发请求，但是B有结果了也不会先返回，也会先按照顺序响应 A 的请求，然后按照顺序响应


---

## HTTP2

### 二进制协议

HTTP 1.1 头信息是 ascll 编码，数据体可以是文本，也可以是二进制，但是 HTTP 2 是一个彻底的二进制协议

### 多工

HTTP 2 复用 TCP 连接，在一个连接里，客户端和浏览器可以同时发布多个请求或者回应，而且不用按照顺序一一对应，这样就避免了队头阻塞

[在线示例](https://http2.akamai.com/demo)

### 数据流

- 因为 HTTP2 不是按照顺序响应的，每个请求和响应里面所有的数据包视为一个流，每个数据流都有唯一的标识，另外还规定客户端发出的数据流 ID 一律为奇数，服务端一律为偶数

- 数据流的取消，1.1版本需要关闭 TCP 连接，2可以取消某一个请求，同时 TCP 连接继续保持，可以被其他请求使用

- 客户端可以指定数据流的优先级，优先级越高，服务端会更快响应

- 头部信息进行压缩后再发出

- 允许服务器主动推送内容，就比如用户访问一个地址，服务器可以把这个地址里面所用的资源全部返回，也就是一个请求可以对应多个响应

---

## HTTP 缓存

### 强制缓存

- expires

  - 指定缓存过期的时间，但是如果服务器和客户端时间不一样，或着资源已经更新，这样都是没办法处理的

- cache-control: max-age=xxx

  - 可以设置多长时间后过期

### 协商缓存

就是在使用本地缓存之前，向浏览器发送一次 get 请求，协商缓存是否已经过期，通常是采用请求资源最近的修改时间来判断的，强制缓存优先与协商缓存

#### last-modified 和 if-modified-since

- 假设客户端要请求一个图片，为了进行协商缓存，那么该请求第一次请求要返回 last-modified 字段，当刷新网页的时候，浏览器无法确定这个请求是本地缓存还是其他，所以先去向服务器发送一个 get 请求，服务器根据 if-modified-sence 判断文件是否被修改过，如果没修改，浏览器就使用本地缓存，使用过服务器就返回新的资源

- 要注意的是协商缓存的有效状态是 304，就是缓存重新定向到本地，对于强制缓存来说如果有效的话，状态码是 200

#### last-modified 不足

- 如果请求的文件资源发生了编辑，但是内容没有改变，时间戳也会更新

- 识别文件资源修改的时间精确到秒，如果文件资源修改时间非常快的话是没有办法识别到资源已经更新了

#### ETAG

为了弥补 last-modified 的不足，http 1.1 制定了 etag，主要是针对不同资源进行哈希运算进行更精确的变化感知，如果和 last-modified 同时存在，etag 的优先级别更高，和 last-modified 一样，在第二次发送请求的时候浏览器会把第一次的 etag 作为 if-none-match 发过去，若缓存验证有效，那么状态码会变成 304，重新指向到本地缓存

不足之处：

- 服务器生成 etag 的运算是有一定开销的，如果文件的修改过于频繁，或者资源的内容过大都会影响性能

- etag 也分为强验证和弱验证，强验证根据内容生成，能保证每个字节相同，弱验证根据部分字节来生成，但无法保证每个字节都相同


#### 缓存过程

<img src='./img/缓存.jpg'>

---


### cache-control

- max-age：多长时间后过期

- s-maxage：表示在代理服务器中的缓存时间，仅在设置 public 时候生效

- no-cache：不是不缓存，是强制进行协商缓存，就是每次浏览器发请求不用去判断请求是否已经过期，而是通过协商来解决

- no-store：表示禁止任何缓存策略，客户端每次请求都要服务器给全新的响应，与 no-cache 互斥

- public：表示既可以被浏览器缓存，也可以被代理服务器缓存

- private：只能被浏览器缓存，默认为 private，与 public 互斥


---

## Service Worker 缓存

独立于浏览器主线程之外的工作线程，所以他不会影响浏览器的渲染，Service Worker 是基于 Web Worker 之上增加了对离线缓存的管理能力

基本特征：

- 独立于浏览器主线程，无法直接操作 DOM

- 部署到线上需要 HTTPS

- 能够监听网站的网络请求，从而进行自定义控制

- 不是用的时候会被终止，需要的时候需要重启，所以我们也可以在 indexDB 存储状态

- 广泛使用 promise 来处理异步

- 消息推送

- 后台同步

## CDN 缓存

内容分发网络，他是构建在现有网络基础之上的虚拟智能网络，部署在各地区的服务器，通过智能调度，可以返回给用户距离最近的响应

## 避免重定向

## 使用服务端渲染