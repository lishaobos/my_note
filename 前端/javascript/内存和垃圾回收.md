
## js 内存机制

- 参考网站

    - https://blog.csdn.net/LY_code/article/details/79809007

    - https://www.guru99.com/stack-vs-heap.html#8

- 数组和对象是引用数据类型，他们三个都存在于堆空间中，对象中的字段也指向堆空间的数据

- 其他基本数据类型存在于栈空间中


### 栈和堆

|参数|栈|堆|
|--|:--:|--|
|数据结构类型|线性数据结构|分层数据结构|
|存取速度|高速存取|比栈慢|
|空间管理|操作系统可有效管理空间，因此内存永远不会碎片化|堆空间使用效率不高。内存可能会变得碎片化，因为首先分配然后释放的内存块。|
|空间大小限制|||
|调整大小|变量无法调整大小|变量可以调整大小|
|内存分配|连续|不连续|
|解除分配|不需要取消分配变量|需要显示取消分配|
|实现|堆栈可以通过三种方式实现：基于数组的简单存储，使用动态内存和基于链表的存储|可以使用数组和树来实现堆|
|主要问题|内存不足|内存碎片|
|灵活性|固定大小|可以调整大小|

- 1.堆栈空间分配区别

    - 1.栈（操作系统）：由操作系统自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈； 

    - 2.堆（操作系统）： 一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收，分配方式倒是类似于链表。

- 2.堆栈缓存方式区别

    - 1.栈使用的是一级缓存， 他们通常都是被调用时处于存储空间中，调用完毕立即释放； 

    - 2.堆是存放在二级缓存中，生命周期由虚拟机的垃圾回收算法来决定（并不是一旦成为孤儿对象就能被回收）。所以调用这些对象的速度要相对来得低一些。 

- 3.堆栈数据结构区别 

    - 1.堆（数据结构）：堆可以被看成是一棵树，如：堆排序； 

    - 2.栈（数据结构）：一种先进后出的数据结构。



## js 的垃圾回收机制

- js垃圾回收器会定期回收内存中不继续使用的变量，释放内存

- 参考网站：

    - https://www.cnblogs.com/zhwl/p/4664604.

    - http://www.cnblogs.com/TomXu/archive/2012/01/18/2312463.html

- 栈空间一般用完就被释放

- 核心思想：分为标记和清除两个阶段完成

- 步骤

    - 1.从全局上下文开始递归遍历所有活动对象

    - 2.遍历内存中所有对象清除没有标记的对象，同时取消第一步对象的标记

    - 3.回收相应的空间

    - 5.缺点是会产生不连续的内存空间，导致内存无法最大化使用（V8 里面有标记整理算法可以把不连续的内存空间整理到一起）
    
- 1.标记清除法

    在函数声明一个变量的时候，就将这个变量标记为“进入环境”。从逻辑上讲，永远都不能释放进入环境的变量作占用的内存，
    因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其标记为“离开环境”。垃圾回收器在运行
    时候会给存储在内存中中的所有变量都加上标记。然后它会去掉环境中的变量以及被环境中的变量引用的变量的标记（闭包）。
    在此之后再被标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后，垃圾回收器完成内存清楚工作，
    销毁那些带标记的值并回收他们所占用的内存空间。
    在JavaScript 中，全局变量（Global）和window 对象会一直存在，不会被垃圾收集器回收； 
    所有没有被标记为“活跃（active）”的，都会被认为是垃圾，收集器释放会回收垃圾，并把内存还给操作系统。

        // 例子
        function test(){ 
            var a = 10 ; //被标记 ，进入环境 
            var b = 20 ; //被标记 ，进入环境 
        } 
        test(); //执行完毕 之后 a、b又被标离开环境，被回收

- 2.引用计数法

    引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是1。
    如果同一个值又被赋给另一个变量，则该值的引用次数加1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减1。
    当这个值的引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。这样，当垃圾回收器下次再运行时，
    它就会释放那些引用次数为0的值所占用的内存。但是很重要的一点是当遇到循环引用的时候，函数的引用次数就不会为0，所以不会被垃圾回收器回收内存，
    会造成内存泄露。在IE中涉及COM对象（IE 中的 bom 和 dom），就会存在循环引用的问题。

    - 1.优点

        - 1.发现垃圾时立即回收

        - 2.最大限度减少程序暂停

    - 2.缺点

        - 1.无法回收循环引用的对象

        - 2.时间开销大

    - 3.例子

            function test(){ 
                var a = {} ; //a的引用次数为0 
                var b = a ; //a的引用次数加1，为1 
                var c =a; //a的引用次数再加1，为2 
                var b ={}; //a的引用次数减1，为1 
            }


#### 关于闭包和垃圾回收机制

- 参考网站： 

    - https://blog.csdn.net/johnny0991/article/details/51778436

    - https://blog.csdn.net/Haley_Guo/article/details/80362559

- 1.闭包基本概念

    - 闭包一般实在函数体内部定义一个函数，内部函数可以访问外部函数的参数，一般以函数作为返回值，或者函数传递参数出现

    - 1.函数作为返回值会导致函数体里面声明的a变量无法被回收

            var a = 1

            function big(){
                var b = 1
                var a = 2
                return function (){
                    console.log(a)
                }
            }

            // 执行这一句的时候就改变了匿名函数的作用域链（吧 big 函数的作用域添加到其中了，在全局和自身之间）
            var c = big()

            // 打印出来 2 ，这个返回的函数引用了 big 函数里面的变量，所以被引用的活动变量是不会被回收的。
            c()

            // 只要解除对这个匿名函数的引用，垃圾回收才会回收这个匿名函数以及 a 变量。
            c = null

            // 如果 b 变量没有被引用，是会被回收的

    - 2.函数传递参数

            // 这个让人明白函数体访问到的参数是在他的作用域的参数，也就是声明函数的地方。
            var a = 1;

            function small (){
                console.log(a)
            }

            function big (callback){
                var a = 2
                callback()
            }

            big(small) // 打印出来 1

- 2.闭包为什么会导致内存泄漏

    解决方法：手动赋值为null，意在切断变量和引用值之间的联系，然后垃圾回收机制就会回收了。

    能导致内存泄漏的一定是引用类型的变量，比如函数和其他自定义对象。而值类型的变量是不存在内存泄漏的，比如字符串、数字、布尔值等。
    因为值类型是靠复制来传递的，而引用类型是靠类似c语言中的指针来传递的。可以认为一个引用类型的变量就是一个指向某个具体的内存地址的指针。

    内存泄漏是指我们已经无法再通过js代码来引用到某个对象，但垃圾回收器却认为这个对象还在被引用，因此在回收的时候不会释放它。
    导致了分配的这块内存永远也无法被释放出来。如果这样的情况越来越多，会导致内存不够用而系统崩溃。

    什么情况会引起内存泄漏？
    虽然有垃圾回收机制但是我们编写代码操作不当还是会造成内存泄漏。

    意外的全局变量引起的内存泄漏。 
    原因：全局变量，不会被回收。 
    解决：使用严格模式避免。

    闭包引起的内存泄漏 
    原因：闭包可以维持函数内局部变量，使其得不到释放。 
    解决：将事件处理函数定义在外部，解除闭包,或者在定义事件处理函数的外部函数中，删除对dom的引用。

    没有清理的DOM元素引用 
    原因：虽然别的地方删除了，但是对象中还存在对dom的引用 
    解决：手动删除。

    被遗忘的定时器或者回调 
    原因：定时器中有dom的引用，即使dom删除了，但是定时器还在，所以内存中还是有这个dom。 
    解决：手动删除定时器和dom。

    子元素存在引用引起的内存泄漏 
    原因：div中的ul li 得到这个div，会间接引用某个得到的li，那么此时因为div间接引用li，即使li被清空，也还是在内存中，并且只要li不被删除，他的父元素都不会被删除。 
    解决：手动删除清空。


#### V8引擎

- 1.内存设置了上限

- 2.采用基于分代回收思想实现垃圾回收

- 3.内存分为新生代和老生代

    - 1.新生代

        - 1.小空间用于存储新生代对象（32M | 16M）

        - 2.新生代指的是存活时间比较短的对象（局部作用域里面的）

        - 3.回收过程采用复制算法 + 标记整理算法

        - 4.新生代内存区分为两个等大空间（使用空间为 From，空闲空间为 To）

        - 5.活动对象存储于 From 对象

        - 6.标记整理后将活动对象拷贝至 To（把 From 里面不连续的空间整理为连续可用的空间）

        - 7.From 和 To 交换空间完成释放

        - 8.细节说明

            - 1.一轮 GC 还存活的新生代，比如闭包无法回收的会晋升到老生代空间

            - 2.To 空间的使用率到一定的程度，会把这些对象晋升到老生代空间

    - 2.老生代

        - 1.大空间用于存储（1.4G | 700M）

        - 2.老年代对象就是指存活时间比较长的对象，比如全局下的或者闭包无法回收的

        - 3.主要采用标记清除，标记整理，增量标记算法

        - 4.细节说明

            - 1.程序执行会和 GC 会交替执行

            - 2.程序执行触发了垃圾回收，此时程序会暂停，然后 GC 算法对对象进行标记，然后程序再执行，再停止，此时继续- 标记然后到了最终垃圾回收的时候程序会暂停，回收完毕程序继续执行
