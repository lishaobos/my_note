# 组件内聚原则

组件内聚原则是关于如何将类组合成组件(或包、模块)的三大原则,由 Robert C. Martin 提出。这些原则帮助我们决定哪些类应该放在一起,哪些应该分开。

---

## 1. REP - Reuse/Release Equivalence Principle (复用/发布等同原则)

**定义**: 复用的粒度就是发布的粒度。软件复用的最小单位应该等同于其发布的最小单位。

### 核心思想
- 组件应该作为一个整体来发布和版本化
- 组件中的类和模块应该是一个内聚的群组
- 要么一起复用,要么都不复用
- 组件应该有明确的版本号和变更记录

### 实践要点

#### 1. 版本管理
```json
// package.json
{
  "name": "@myapp/user-module",
  "version": "1.2.3",
  "description": "User management module",
  "main": "index.js",
  "dependencies": {
    "lodash": "^4.17.21"
  }
}
```

#### 2. 内聚的组件结构
```
user-module/
├── package.json
├── CHANGELOG.md
├── README.md
├── src/
│   ├── User.js          // 用户实体
│   ├── UserService.js   // 用户服务
│   ├── UserRepository.js // 用户仓储
│   └── index.js         // 统一导出
└── tests/
```

#### 3. 统一导出
```javascript
// index.js - 作为一个整体对外暴露
export { User } from './User';
export { UserService } from './UserService';
export { UserRepository } from './UserRepository';
```

### ❌ 反例：违反 REP

```javascript
// 不内聚的组件 - 混杂了不相关的功能
// @myapp/utils 包含了各种不相关的工具
export { formatDate } from './date-utils';
export { validateEmail } from './email-utils';
export { DatabaseConnection } from './db';
export { Logger } from './logger';
export { cryptoHash } from './crypto';

// 问题:
// 1. 用户只想用 formatDate,却要安装整个包
// 2. Logger 更新导致整个包版本升级
// 3. 各个功能没有内聚关系
```

### ✅ 正例：符合 REP

```javascript
// 拆分成多个内聚的包
// @myapp/date-utils
export { formatDate, parseDate, dateRange };

// @myapp/validation
export { validateEmail, validatePhone, validateUrl };

// @myapp/database
export { DatabaseConnection, QueryBuilder };

// @myapp/logger
export { Logger, FileLogger, ConsoleLogger };
```

### 实际应用

1. **npm 包发布**: 每个包应该是一个可独立发布和版本化的单元
2. **语义化版本**: 遵循 semver 规范 (major.minor.patch)
3. **变更日志**: 维护 CHANGELOG.md 记录每次发布的变更
4. **依赖管理**: 明确声明外部依赖

---

## 2. CCP - Common Closure Principle (共同封闭原则)

**定义**: 为了相同目的而同时修改的类,应该放在同一个组件中。

### 核心思想
- 将会同时变化的类放在一起
- 最小化变更的影响范围
- 降低发布频率和风险
- "一起变化的类应该在一起"

### 类比
- **CCP 是 SRP 在组件层面的应用**
- SRP: 一个类只有一个变化的理由
- CCP: 一个组件只有一个变化的理由

### ✅ 正例：符合 CCP

```javascript
// 用户认证模块 - 认证相关的类放在一起
// auth-module/
class AuthService {
  login(credentials) {}
  logout() {}
  refreshToken(token) {}
}

class TokenManager {
  generateToken(user) {}
  validateToken(token) {}
  revokeToken(token) {}
}

class SessionStore {
  create(userId, token) {}
  get(sessionId) {}
  destroy(sessionId) {}
}

// 这些类因为"认证策略变化"会同时修改
// 例如: 从 JWT 改为 OAuth2.0
```

### ❌ 反例：违反 CCP

```javascript
// user-module/ - 混杂了不同变化原因的类
class User {
  // 用户实体 - 因业务规则变化而修改
}

class EmailService {
  // 邮件服务 - 因邮件提供商变化而修改
  sendEmail() {}
}

class UserRepository {
  // 数据访问 - 因数据库变化而修改
  save(user) {}
}

class PdfGenerator {
  // PDF 生成 - 因报表格式变化而修改
  generateUserReport(user) {}
}

// 问题: 这些类的变化原因各不相同,不应该放在一起
```

### 实际场景示例

#### 场景 1: UI 组件库

```javascript
// ✅ 按变化原因组织
// button-components/  - 按钮相关,样式变化时一起改
├── Button.jsx
├── IconButton.jsx
├── ButtonGroup.jsx
└── button.styles.js

// form-components/   - 表单相关,验证逻辑变化时一起改
├── Input.jsx
├── Select.jsx
├── Form.jsx
└── validators.js
```

#### 场景 2: 支付系统

```javascript
// payment-gateway/  - 支付网关逻辑,支付接口变化时一起改
class PaymentGateway {
  process(payment) {}
}

class PaymentValidator {
  validate(payment) {}
}

class PaymentLogger {
  logTransaction(payment) {}
}

// notification-service/  - 通知服务,通知渠道变化时一起改
class NotificationService {
  notifyUser(userId, message) {}
}

class EmailNotifier {
  send(email, content) {}
}

class SmsNotifier {
  send(phone, content) {}
}
```

### CCP 的优势

1. **减少连锁变更**: 变更被限制在单个组件内
2. **简化发布**: 相关的变更可以一次性发布
3. **提高可维护性**: 相关代码在一起,更容易理解和修改
4. **降低测试成本**: 变更影响范围小,测试范围也小

---

## 3. CRP - Common Reuse Principle (共同复用原则)

**定义**: 不要强迫一个组件的用户依赖他们不需要的东西。

### 核心思想
- 不应该依赖有不需要的类的组件
- 组件中的类应该是不可分割的
- 如果复用组件的一部分,就应该复用组件的全部
- "一起复用的类应该在同一个组件中"

### 类比
- **CRP 是 ISP 在组件层面的应用**
- ISP: 不应该依赖不需要的接口
- CRP: 不应该依赖不需要的组件

### ✅ 正例：符合 CRP

```javascript
// date-utils/  - 日期工具,通常一起使用
export function formatDate(date, format) {}
export function parseDate(dateString) {}
export function addDays(date, days) {}
export function diffDays(date1, date2) {}

// 使用场景:
import { formatDate, parseDate, addDays } from '@myapp/date-utils';
// 即使导入了多个函数,它们都是处理日期的,高度相关
```

### ❌ 反例：违反 CRP

```javascript
// utils/  - 大杂烩工具包
export function formatDate(date) {}      // 日期相关
export function validateEmail(email) {} // 验证相关
export function httpGet(url) {}         // 网络相关
export function cryptoHash(text) {}     // 加密相关
export function logger(message) {}      // 日志相关

// 使用场景:
import { formatDate } from '@myapp/utils';
// 问题:
// 1. 只需要 formatDate,却依赖了整个 utils 包
// 2. utils 包更新时,即使只改了 logger,也要更新
// 3. 打包时可能包含不需要的代码
```

### 实际场景示例

#### 场景 1: React 组件库

```javascript
// ❌ 不好的组织方式 - 强制依赖不需要的东西
// ui-components/
export { Button } from './Button';
export { Modal } from './Modal';
export { Chart } from './Chart';  // 依赖 D3.js (大型库)
export { Calendar } from './Calendar';  // 依赖 date-fns

// 用户只想用 Button,却要安装 D3.js 和 date-fns

// ✅ 好的组织方式 - 按复用粒度拆分
// @ui/button
export { Button };

// @ui/modal
export { Modal };

// @ui/charts  - 单独的包,只有需要的人才安装
export { Chart };

// @ui/calendar
export { Calendar };
```

#### 场景 2: 工具库拆分

```javascript
// ❌ lodash (整体) - 可能只用了几个函数,却要安装整个库
import _ from 'lodash';
_.map(array, fn);

// ✅ lodash (按需引入) - 只依赖需要的部分
import map from 'lodash/map';
map(array, fn);

// ✅ 更好的方式 - ES6 原生方法
array.map(fn);
```

#### 场景 3: 微服务架构

```javascript
// ❌ 单体服务 - 所有功能都在一起
class AppService {
  // 用户管理
  createUser() {}
  deleteUser() {}
  
  // 订单管理
  createOrder() {}
  cancelOrder() {}
  
  // 支付处理
  processPayment() {}
  refund() {}
  
  // 报表生成
  generateReport() {}
}

// 问题: 订单服务需要依赖整个 AppService,
// 包括不需要的支付和报表功能

// ✅ 拆分成独立的服务
class UserService {
  createUser() {}
  deleteUser() {}
}

class OrderService {
  createOrder() {}
  cancelOrder() {}
}

class PaymentService {
  processPayment() {}
  refund() {}
}

class ReportService {
  generateReport() {}
}
```

### CRP 的实践技巧

1. **Tree Shaking**: 利用现代打包工具的 tree shaking 特性
2. **按需加载**: 使用动态 import 延迟加载不常用的功能
3. **Peer Dependencies**: 让使用者自己安装可选的依赖
4. **插件化架构**: 核心包保持小巧,功能通过插件扩展

```json
// package.json - 使用 peerDependencies
{
  "name": "@myapp/charts",
  "dependencies": {},
  "peerDependencies": {
    "d3": "^7.0.0"  // 让使用者自己安装
  }
}
```

---

## 三大原则的关系与平衡

### 原则对比

| 原则 | 关注点 | 目标 | 类比 |
|------|--------|------|------|
| REP | 发布和复用 | 组件可独立发布 | - |
| CCP | 变化管理 | 减少变更影响 | 组件级的 SRP |
| CRP | 依赖管理 | 避免不必要依赖 | 组件级的 ISP |

### 原则之间的张力

```
       CCP
        ↑
        |
    使组件变大
        |
REP ←---+---→ CRP
    使组件变小
```

- **CCP vs CRP**: 
  - CCP 倾向于让组件变大(把一起变化的放在一起)
  - CRP 倾向于让组件变小(减少不必要的依赖)
  
- **REP**: 在两者之间找平衡

### 如何平衡

#### 1. 早期项目 - 偏向 CCP
```javascript
// 快速迭代阶段,避免频繁的组件拆分
// user-module/ - 包含用户相关的所有功能
├── User.js
├── UserService.js
├── UserRepository.js
├── UserValidator.js
└── UserNotifier.js
```

#### 2. 成熟项目 - 偏向 CRP
```javascript
// 稳定后,拆分成更细粒度的组件
// @app/user-core       - 核心用户功能
// @app/user-validation - 用户验证
// @app/user-notification - 用户通知
```

#### 3. 实际决策流程

```
是否需要拆分组件?
  ↓
1. 变化原因是否不同? (CCP)
   是 → 考虑拆分
   否 → 保持在一起
   ↓
2. 是否有不同的复用场景? (CRP)
   是 → 考虑拆分
   否 → 保持在一起
   ↓
3. 拆分后是否便于发布管理? (REP)
   是 → 拆分
   否 → 保持在一起
```

---

## 实践建议

### 1. 从粗到细
- 初期: 按大的功能模块划分
- 中期: 发现频繁变化的部分,考虑拆分
- 后期: 根据复用情况优化组件粒度

### 2. 监控指标
- **组件耦合度**: 组件间依赖关系
- **变更频率**: 组件修改的频率
- **复用率**: 组件被其他模块使用的次数

### 3. 重构时机
- 发现一个组件有多个变化原因时 → 考虑应用 CCP
- 发现组件被部分使用时 → 考虑应用 CRP
- 发现组件难以版本管理时 → 考虑应用 REP

### 4. 团队协作
- 建立组件命名规范
- 文档化组件的职责和边界
- 代码审查时关注组件职责

---

## 总结

### 核心记忆口诀

- **REP**: "发布即复用" - 能独立发布的才能被复用
- **CCP**: "一起变化的在一起" - 组件级的单一职责
- **CRP**: "不强迫不需要的依赖" - 组件级的接口隔离

### 与 SOLID 的对应关系

| 组件内聚原则 | 对应的 SOLID 原则 | 层次 |
|--------------|-------------------|------|
| CCP | SRP (单一职责) | 组件层 |
| CRP | ISP (接口隔离) | 组件层 |
| REP | - | 组件层特有 |

### 实践检查清单

✅ 每个组件有明确的版本号和变更日志 (REP)  
✅ 组件内的类因相同原因而修改 (CCP)  
✅ 组件没有强迫用户依赖不需要的功能 (CRP)  
✅ 组件的依赖关系清晰且最小化  
✅ 组件的职责边界明确  
