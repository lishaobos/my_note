***关于js内存机制
    参考网站：https://blog.csdn.net/LY_code/article/details/79809007
    1.数组，对象，函数
        数组和对象是引用数据类型，他们三个都存在于堆空间中，对象中的字段也指向堆空间的数据
    2.其他基本数据类型
        存在于栈空间中
    栈和堆的区别
　　一、堆栈空间分配区别： 
　　1、栈（操作系统）：由操作系统自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈； 
　　2、堆（操作系统）： 一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收，分配方式倒是类似于链表。 
　　二、堆栈缓存方式区别： 
　　1、栈使用的是一级缓存， 他们通常都是被调用时处于存储空间中，调用完毕立即释放； 
　　2、堆是存放在二级缓存中，生命周期由虚拟机的垃圾回收算法来决定（并不是一旦成为孤儿对象就能被回收）。所以调用这些对象的速度要相对来得低一些。 
　　三、堆栈数据结构区别： 
　　堆（数据结构）：堆可以被看成是一棵树，如：堆排序； 
　　栈（数据结构）：一种先进后出的数据结构。


***关于 js 的垃圾回收机制
    js垃圾回收器会定期回收内存中不继续使用的变量，释放内存
    参考网站：
        https://www.cnblogs.com/zhwl/p/4664604.html
        http://www.cnblogs.com/TomXu/archive/2012/01/18/2312463.html
    1.标记清除法
        在函数声明一个变量的时候，就将这个变量标记为“进入环境”。从逻辑上讲，永远都不能释放进入环境的变量作占用的内存，
        因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其标记为“离开环境”。垃圾回收器在运行
        时候会给存储在内存中中的所有变量都加上标记。然后它会去掉环境中的变量以及被环境中的变量引用的变量的标记（闭包）。
        在此之后再被标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后，垃圾回收器完成内存清楚工作，
        销毁那些带标记的值并回收他们所占用的内存空间。
        在JavaScript 中，全局变量（Global）和window 对象会一直存在，不会被垃圾收集器回收； 
        递归所用到的所有（包括变量和方法），都不会被回收； 
        所有没有被标记为“活跃（active）”的，都会被认为是垃圾，收集器释放会回收垃圾，并把内存还给操作系统。
        例：
        function test(){ 
            var a = 10 ; //被标记 ，进入环境 
            var b = 20 ; //被标记 ，进入环境 
        } 
        test(); //执行完毕 之后 a、b又被标离开环境，被回收
    2.引用计数法
        引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是1。
        如果同一个值又被赋给另一个变量，则该值的引用次数加1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减1。
        当这个值的引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。这样，当垃圾回收器下次再运行时，
        它就会释放那些引用次数为0的值所占用的内存。但是很重要的一点是当遇到循环引用的时候，函数的引用次数就不会为0，所以不会被垃圾回收器回收内存，
        会造成内存泄露。在IE中涉及COM对象，就会存在循环引用的问题。
        例：
        function test(){ 
            var a = {} ; //a的引用次数为0 
            var b = a ; //a的引用次数加1，为1 
            var c =a; //a的引用次数再加1，为2 
            var b ={}; //a的引用次数减1，为1 
        }


***关于闭包和垃圾回收机制
    参考网站：  
        https://blog.csdn.net/johnny0991/article/details/51778436
        https://blog.csdn.net/Haley_Guo/article/details/80362559
    1.闭包基本概念
        闭包一般实在函数体内部定义一个函数，内部函数可以访问外部函数的参数，一般以函数作为返回值，或者函数传递参数出现
        1.函数作为返回值
            会导致函数体里面声明的a变量无法被回收
            var a = 1
            function big(){
                var a = 2
                return function (){
                    console.log(a)
                }
            }
            big()() //打印出来 2
        2.函数传递参数
            这个让人明白函数体访问到的参数是在他的作用域的参数，也就是声明函数的地方。
            var a = 1;
            function small (){
                console.log(a)
            }
            function big (callback){
                var a = 2
                callback()
            }
            big(small) //打印出来 1
    2.闭包为什么会导致内存泄漏
        能导致内存泄漏的一定是引用类型的变量，比如函数和其他自定义对象。而值类型的变量是不存在内存泄漏的，比如字符串、数字、布尔值等。
        因为值类型是靠复制来传递的，而引用类型是靠类似c语言中的指针来传递的。可以认为一个引用类型的变量就是一个指向某个具体的内存地址的指针。

        内存泄漏是指我们已经无法再通过js代码来引用到某个对象，但垃圾回收器却认为这个对象还在被引用，因此在回收的时候不会释放它。
        导致了分配的这块内存永远也无法被释放出来。如果这样的情况越来越多，会导致内存不够用而系统崩溃。

        什么情况会引起内存泄漏？
        虽然有垃圾回收机制但是我们编写代码操作不当还是会造成内存泄漏。

        意外的全局变量引起的内存泄漏。 
        原因：全局变量，不会被回收。 
        解决：使用严格模式避免。

        闭包引起的内存泄漏 
        原因：闭包可以维持函数内局部变量，使其得不到释放。 
        解决：将事件处理函数定义在外部，解除闭包,或者在定义事件处理函数的外部函数中，删除对dom的引用。

        没有清理的DOM元素引用 
        原因：虽然别的地方删除了，但是对象中还存在对dom的引用 
        解决：手动删除。

        被遗忘的定时器或者回调 
        原因：定时器中有dom的引用，即使dom删除了，但是定时器还在，所以内存中还是有这个dom。 
        解决：手动删除定时器和dom。

        子元素存在引用引起的内存泄漏 
        原因：div中的ul li 得到这个div，会间接引用某个得到的li，那么此时因为div间接引用li，即使li被清空，也还是在内存中，并且只要li不被删除，他的父元素都不会被删除。 
        解决：手动删除清空。


***原型链
    https://www.jianshu.com/p/116ea3be6ef5
    https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain
    https://www.zhihu.com/question/34183746
    https://www.cnblogs.com/libin-1/p/6014925.html
    *** https://chen-cong.blog.csdn.net/article/details/81211729
    我们需要牢记两点：①__proto__和constructor属性是对象所独有的；② prototype属性是函数所独有的，因为函数也是一种对象，
    所以函数也拥有__proto__和constructor属性。
    __proto__属性的作用就是当访问一个对象的属性时，如果该对象内部不存在这个属性，那么就会去它的__proto__属性所指向的那个对象（父对象）里找，一直找，
    直到__proto__属性的终点null，然后返回undefined，通过__proto__属性将对象连接起来的这条链路即我们所谓的原型链。
    prototype属性的作用就是让该函数所实例化的对象们都可以找到公用的属性和方法，即f1.__proto__ === Foo.prototype。
    constructor属性的含义就是指向该对象的构造函数，所有函数（此时看成对象了）最终的构造函数都指向Function。




***关于Object.defineProperty(obj,'yo',{ // obj是定义的对象，yo是属性
    set(e){
        // 当 obj.yo = anythine 就会进来这个函数，e 是我们修改的 obj对象的yo属性的值
    },
    get(){
        // 当 obj.yo  就会进来这个函数
    },
    value:'xxx', // 这个就是我们定义的 yo 属性的值
    enumerable: false // 这个是 false 就是代表不可枚举, true 就是代表可枚举
    configurable: false //如果为false,就不能设置他的value
})
    1.对象的可枚举属性和不可枚举属性的区别
        1.可枚举属性就是我们 for in 循环可以打印出来的属性
        2.不可枚举属性我们在对象中可以使用，也可以看见，但是 for in 循环是打印不出来这个属性的

***关于es6连续箭头函数
    let yo = a => b => return a + b
    相当于 function yo(a){
            return function (b){
                return a + b
            }
          }
    执行形式：yo(2)(3) //都是这样
    
    
    
***关于 js 执行上下文，环境栈
    **声明函数的区别
        1.let a = function () {console.log(111)}
        2.function a () {console.log(111)}
        speaker:
            第一种是必须在 let 语句之后函数才生效
            第二种是会变量提升到最高级别，比 var 这些还高，并且在函数声明之前就可以调用,并且 a.name(提供这个属性，就是函数的名字)
     **apply call bind
        1.apply，call，bind 都是可以改变函数的执行上下文
        2.apply(object,[]) call(object,'','') bind(object,'',) //这是使用的方式，如果不传参数，只写一个参数就行了
        3.apply 和 call 都是让函数的 this 指向指向到我们传入的 object,bind也是，不过 bind 是返回一个新的函数
        4.apply，call，这连个方法执行的时候只有该次 this 的指向是我们传入的对象，其他时候原本函数执行的时候还是指向原来的
        5.bind绑定会返回一个新函数，所以这个新函数每次执行的时候 this 都会指向到我们绑定的 对象
        6.一些点说一下
            假设 function a(){
                    console.log(this.num)
                   }
                let b = {num:123}
                a.apply(b)
                然后 a() 就会打印出来 123
            还有之前的一个疑惑
                 function a(){
                    console.log(this.num)
                  }
                  var b = new a; b.num = 123
                  a() 打印出来 undefined //按理来说 this 不是应该指向我们实例的对象身上吗
                  因为 var b = new a 这段代码会重新执行 a 函数，但这个时候 对象没有实例化结束，this指向的是 a函数，
                  因为函数本身也是一个对象，所以这个时候 this 指向的是自身当执行完成之后会创建一个新对象 b，会执行原型链接，
                  将构造函数 a 的作用域赋给 b 对象，也就是 this的指向指到了 b ，如果函数内部没有返回新的对象的话，new 表达式会自动返回这个新对象。
                  
                  a()这种执行 this 还是指向的是 window 对象
                  
 ***ES6中的一部分东西
    1.箭头函数
        1.函数体内没有 this，只能从外层继承,因为没有 this，所以也不可以作为构造函数，new 对象就是不可以的。
        2.不可以使用 arguments对象。
        3.不可以使用 yield
        4.不适用场景：
            因为没有 this，所以 call apply bind 这些方法对箭头函数式不起作用的
            例子：
                const cat = {
                     lives: 9,
                    jumps: () => {
                        this.lives--;
                    }
                   }
             执行cat.jumps的时候，如果是普通函数就会奏效，如果是例子中的箭头函数，就不会奏效，
             **原因是对象不构成单独的作用域，导致jumps箭头函数定义时的作用域就是全局作用域。（打破了大括号作用域的认知）
                  
                  
        
