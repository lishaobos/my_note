***对于项目中的一些总结和记录
    1.整体的换肤，整体的样式改变
        1.可以封装一些组件，比如说按钮，可以根据我们的样式来
        2.不需要封装组件的时候可以写整体的 css ，写上几套
            1.在 main.js 中 可以写一个判断样式的函数 function sty (){},在函数中根据判断条件 import ('./x.css') //这种带括号引入可以写在函数中
            2.在 public 文件下的 index.html 也可以判断，然后用js创建一个 link 标签，然后给他的 href 属性变成我们想要的css
            3.经测试 1中 import('xx.css')引入一次就固定了，不会产生动态切换样式的效果
            4.新的思路，给body或者html起一个类名，在不同类名下写入不同的样式，到时候修改 className就可以动态皮肤
            
    2.左边的菜单从数据库获取（意义在于以后可以根据特定的人加载不同的菜单）// vue的 addRoutes 异步路由方法
    
    3.王哥：对于像是router里面的组件，或者一些要引入的组件，最后可以配置不打包，然后通过cdn的方式引入，可以加快速度
    
    4.关于 echarts 的一些遇到的东西
        1.resize() 是echarts 提供的方法，可以根据浏览器的视窗大小进行重绘
        2.因为 echarts 是根据已经实例好的 dom 元素进行绘制，所以在进行一些其他操作，比如说是改变主题，或者是要全屏或者其他操作，都得重新 init（注意配
          合 $nextTick）
        3.关于主题或者自己定制主题
            1.系统只提供了 dark light '' 三种基本的主题
            2.使用方法：
                1.在 echarts 官网提供了一些主题，点击定制主题里面也有好多方案，都可以下载，然后这里面也可以自己配置自己的主题
                2.注意第一步下载的主题的文件名是不能自己进行修改的，在vue中得放在 node_moudles 下面的 echarts文件夹下面的theme文件夹下
                3.我们除了第一步官网提供的三个主题，其他都是要额外引入的（例：import 'echarts/theme/chalk.js'）*注意在引入echarts后面引入
                
    5.关于 base64 转码的问题
        1.let reader = new FileReader()
        2.reader.readAsDataURL(文件)
        3.reader.onload = _ => {console.log(reader.result) //这个就是转的 base64 }
        4.最好写上 reader.onerror = _ => {//错误提示} //防止意外发生
        
    6.关于项目中的 lodash 的使用
        1.使用深克隆
        2.使用防抖和节流（防止按钮或者事件在短时间内触发多次） //这俩其实是一样的
            1.debounce(function,time,option:{}) //应用场景：input输入完毕触发事件，onresize页面reflow
                debounce就是在time时间内如果触发事件，那么下次触发会延迟到这次点击之后过 time 事件
                选项 leading 是在触发延迟之前执行 （只写这个就是狂点按钮，事件只会在第一次和最后一次生效）
                选项 trailing 是在触发延迟之后执行 （只写这个就是狂点按钮，最后一次生效）
                选项 maxWait 是保证这个时间段内必定执行一次
            2.throttle(function,time,option:{}) //应用场景：滚动条滚动时
                这个其实和 debounce 一样，只是规定time时间段内必定执行一次，只是延迟之前和延迟之后的关系
                
    7.关于 element 遇到的一些日鬼的问题
        1.popover 在表格循环生成的时候会发生无法关闭的问题
            解决办法： 调用不知道在哪里的 doClose 方法
                 <el-popover
                  :ref="'popover-'+scope.row.id"
                  placement="top"
                  width="160"
                  trigger="click"
                >
                  <p>确定删除吗？</p>
                  <div style="text-align: right; margin: 0">
                    <el-button
                      size="mini"
                      type="text"
                      @click="$refs['popover-'+scope.row.id].doClose()"
                    >取消</el-button>
                    <el-button
                      type="danger"
                      size="mini"
                      @click="$refs['popover-'+scope.row.id].doClose(),deldepartment(scope.row.gid)"
                    >确定</el-button>
                  </div>
                  <!-- <el-button slot="reference">删除</el-button> -->
                  <deletes slot="reference"  :disabled="dis"/>
                </el-popover>
     
     8.关于vue的导航栏
        在切换导航的时候，或者用户点击浏览器的前进或者后退的时候，我们得监听路由的实时切换，所以我们在导航这个组件页面中
        只要实时监听当前路由的变化就行了，例如：
        watch:{
            ['$route.path'](newPath,oldPath){
            //这里面我们就可以干我们想干的事情
          }
        }
       
     9.关于 H5 调用手机摄像头
        input 标签提供了 capture 属性,目前知道的有三个
        例如： 'camera'//摄像头 'microphone'//音频 'camcorder'//视频
        调用完成之后获取表单对象里面的文件，做自己想做的事情就行了
     
     10.关于 vue 打包优化问题
     vue.config.js中 vue 提供了 configureWebpack 对象，这个对象就是 webpack 的配置项。
     打包配置例子：
        configureWebpack:{
            externals:{
                //下面这两个的意思就是 vue和element-ui都不会被打包
                'vue':'vue',
                'element-ui':'element-ui'
            }
        }
      1.首先得把 main.js 或者其他地方 import element from 'element-ui'这些东西去掉，要不然会报错（ELEMENT 是element提供的全局变量）
      2.就好了
      
      11.关于 axios 有些后端需要FormData数据格式
        1.把axios请求头变成 headers:{'Content-Type': 'application/x-www-form-urlencoded;charset=utf-8'},
        2.引入安装 axios 自带的 qs import qs from 'qs'
        3.在请求拦截的时候格式化数据 qs.stringify(data) 
      
      12.关于 router 的 addRoutes
        1.这个方法可以给实例化的路由添加异步路由信息
        2.关于更换比如说用户的权限菜单，如果要实现不刷新，新路由换掉已有的路由信息，不是追加：
            例：
                //原本的路由
                let router = new VueRouter({
                    routes
                })
                //重置路由的方法
                let resetRouter = (asyncRoutes) => {
                    let router_ = new VueRouter({
                        routes:[]
                    }) 
                    router.matcher = router.matcher //因为路由信息全部存放在matcher里面，这样就相当于初始化路由。
                    asyncRoutes.push({path:'8',redirect:'/404'})//这个得放在最后添加，要不页面会跳转到404
                    router.addRoutes(asyncRoutes)
                }
        3.在路由拦截因为我们要获取异步路由，所以会出现一些问题
            例：
                router.beforeEatch((to,from,next) => {
                    if(***){
                        resetRouter(asyncRoutes)//添加异步路由
                        next(to)//因为直接 next() 页面会跳到404，文档上说是执行addRoutes有可能还没有完成，这样直接就给她跳到一个新的路由元信息
                    }else{
                        next()//下次进来addRoutes会执行完毕，这个 next() 就会直接成功了
                    }
                })
             但是项目中的 刷新会跳转 404 不知道什么原因，已经这样处理过，但是还是会失败，有一丝日鬼。
